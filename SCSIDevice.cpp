/*
 * SCSIDevice.cpp
 *
 *  Created on: Feb 1, 2018
 *      Author: mmalakanov
 */


#include <stdint.h>
#include "my_debug.h"
#include "SCSI.h"
#include "MSC.h"
//#include <SD.h>
//#include <utility/Sd2Card.h>
#include "LcdConsole.h"

#include "SCSIDevice.h"

SCSIDevice::SCSIDevice():
	lastLBA(0), blockSize(SD_BLOCK_SIZE), sdCardErrorCode(0), sdCardErrorData(0){
/*	sdCard = new Sd2Card();
	sdCard->init();
	sdCardErrorCode = sdCard->errorCode();
	sdCardErrorData = sdCard->errorData();
	*/
	memset(blockData,0,512);
	memset(inquiryData.array, 0,sizeof(inquiryData));
	memset(capacity10.array , 0,sizeof(capacity10));
}

SCSIDevice::~SCSIDevice() {
	// TODO Auto-generated destructor stub
	//delete sdCard;
}

int SCSIDevice::processInquiry(SCSI_CBD_INQUIRY  &cbd, uint8_t* &data, uint16_t& len) {
	lcdConsole.println("Inquiry:"+ String(len));
	lcdConsole.refresh();
	memset(&inquiryData, 0, sizeof(inquiryData));
	inquiryData.inquiry.peripheral_device_type = SCSI_SBC2;
	inquiryData.inquiry.RMB = 1;
	inquiryData.inquiry.version = SCSI_SPC2; // SPC-2
	inquiryData.inquiry.additional_length = 32;
	uint8_t v[8] = {'M','M','7',' ',' ',' ',' ',' '};
	memcpy(inquiryData.inquiry.t10_vendor_id, v, 8);
	uint8_t p[16] = {'S','V','M','L',' ','A','F','M','0',' ',' ',' ',' ',' ',' ',' '};
	memcpy(inquiryData.inquiry.product_id, p, 16);
	uint8_t r[4] = {'0','0','0','1'};
	memcpy(inquiryData.inquiry.product_revision_level, r, 4);
	uint8_t s[8] = {'1','2','3','4','5','6','7','8'};
	memcpy(inquiryData.inquiry.drive_serial_number, s, 8);
	data = inquiryData.array;
	if (len > sizeof(inquiryData))
		len = sizeof(inquiryData);
	return len;
}

int SCSIDevice::processTestUnitReady(SCSI_CBD_TEST_UNIT_READY  &cbd, uint8_t* &data, uint16_t& len) {
	//TODO Check if SD is ready
	///if (!sdCard) return NO_MEDIA;
	//if (!(sdCard->type() waitNotBusy(SD_INIT_TIMEOUT))) return MEDIA_BUSY;
	data = NULL;
	len = 0;
	return MEDIA_READY;
}

int SCSIDevice::processModeSense6(SCSI_CBD_MODE_SENSE_6  &cbd, uint8_t* &data, uint16_t& len) {
	lcdConsole.println("ModeSense:"+String(len));
	lcdConsole.refresh();
	if (cbd.PC == 0){ // current values
		if (cbd.page_code == 0x3F)
			if (cbd.subpage_code == 0x00 ) {
				modesenseData6.fields.mode_data_length = 3;
				modesenseData6.fields.medium_type = 0x00;
				modesenseData6.fields.dev_specific_param  = 0x00;
				modesenseData6.fields.block_descr_length = 0;
			}
	}
	data = modesenseData6.array;
	len = 4;
	return 4;
}

int SCSIDevice::processMediumRemoval(SCSI_CBD_PREVENT_ALLOW_MEDIUM_REMOVAL &cbd, uint8_t* &data, uint16_t& len){
	lcdConsole.println("MediumRemoval:"+String(len));
	lcdConsole.refresh();
	// if (sdCard in ) return 0
	// else return ERROR_NO_MEDIA
	//data =
	//len = ;
	return 0;
}

int SCSIDevice::processReadCapacity10(SCSI_CBD_READ_CAPACITY_10  &cbd, uint8_t* &data, uint16_t& len) {
	lcdConsole.println("ReadCapacity10:"+ String(len));
	lcdConsole.refresh();
	///uint32_t sz = sdCard->cardSize();
	///capacity10.fields.lastLBA  = sz - 1;
	lastLBA = 0xFFFFF;
	SCSI_CAPACITY_DATA_10 cd;
	cd.fields.lastLBA = lastLBA;
	cd.fields.block_sz = blockSize;

	msb2lsb(cd.fields.lastLBA, capacity10.fields.lastLBA);
	msb2lsb(cd.fields.block_sz, capacity10.fields.block_sz);

	//debugPrintlnSX("  capacity:", capacity10.array, len);
	data = capacity10.array;
	len = sizeof(capacity10);
	return len;
}

uint16_t toUint16(uint8_t a[2]){
	return a[0]<<8 | a[1];
}
uint32_t toUint32(uint8_t a[4]){
	return a[0]<<24 | a[1]<<16 | a[2]<<8 | a[3];
}

uint8_t BLOCK0[512] = {
		  0xfa, 0x33, 0xc0, 0x8e, 0xd0, 0xbc, 0x00, 0x7c, 0x8b, 0xf4, 0x50, 0x07,
		  0x50, 0x1f, 0xfb, 0xfc, 0xbf, 0x00, 0x06, 0xb9, 0x00, 0x01, 0xf2, 0xa5,
		  0xea, 0x1d, 0x06, 0x00, 0x00, 0xbe, 0xbe, 0x07, 0xb3, 0x04, 0x80, 0x3c,
		  0x80, 0x74, 0x0e, 0x80, 0x3c, 0x00, 0x75, 0x1c, 0x83, 0xc6, 0x10, 0xfe,
		  0xcb, 0x75, 0xef, 0xcd, 0x18, 0x8b, 0x14, 0x8b, 0x4c, 0x02, 0x8b, 0xee,
		  0x83, 0xc6, 0x10, 0xfe, 0xcb, 0x74, 0x1a, 0x80, 0x3c, 0x00, 0x74, 0xf4,
		  0xbe, 0xf8, 0x06, 0xac, 0x3c, 0x00, 0x74, 0x0b, 0x56, 0xbb, 0x07, 0x00,
		  0xb4, 0x0e, 0xcd, 0x10, 0x5e, 0xeb, 0xf0, 0xeb, 0xfe, 0xbf, 0x05, 0x00,
		  0x60, 0x6a, 0x00, 0x6a, 0x00, 0xff, 0x76, 0x0a, 0xff, 0x76, 0x08, 0x6a,
		  0x00, 0x68, 0x00, 0x7c, 0x6a, 0x01, 0x6a, 0x10, 0xb4, 0x42, 0xb2, 0x80,
		  0x8b, 0xf4, 0xcd, 0x13, 0x61, 0x61, 0x73, 0x0c, 0x33, 0xc0, 0xcd, 0x13,
		  0x4f, 0x75, 0xd9, 0xbe, 0xf8, 0x06, 0xeb, 0xbf, 0xbe, 0xf8, 0x06, 0xbf,
		  0xfe, 0x7d, 0x81, 0x3d, 0x55, 0xaa, 0x75, 0xb3, 0xbf, 0x52, 0x7c, 0x81,
		  0x3d, 0x46, 0x41, 0x75, 0x07, 0x47, 0x47, 0x80, 0x3d, 0x54, 0x74, 0x11,
		  0xbf, 0x03, 0x7c, 0x81, 0x3d, 0x4e, 0x54, 0x75, 0x40, 0x47, 0x47, 0x81,
		  0x3d, 0x46, 0x53, 0x75, 0x38, 0x60, 0xb4, 0x08, 0xb2, 0x80, 0xcd, 0x13,
		  0xbf, 0x1a, 0x7c, 0xfe, 0xc6, 0x8a, 0xd6, 0x32, 0xf6, 0x89, 0x15, 0x4f,
		  0x4f, 0x83, 0xe1, 0x3f, 0x89, 0x0d, 0x61, 0x60, 0x6a, 0x00, 0x6a, 0x00,
		  0xff, 0x76, 0x0a, 0xff, 0x76, 0x08, 0x6a, 0x00, 0x68, 0x00, 0x7c, 0x6a,
		  0x01, 0x6a, 0x10, 0xb4, 0x43, 0xb2, 0x80, 0x8b, 0xf4, 0xcd, 0x13, 0x61,
		  0x61, 0x8b, 0xf5, 0xea, 0x00, 0x7c, 0x00, 0x00, 0x45, 0x72, 0x72, 0x6f,
		  0x72, 0x21, 0x00, 0x44, 0x32, 0x31, 0x30, 0x41, 0x36, 0x31, 0x35, 0x2d,
		  0x41, 0x43, 0x46, 0x44, 0x2d, 0x34, 0x31, 0x34, 0x61, 0x2d, 0x42, 0x44,
		  0x46, 0x31, 0x2d, 0x46, 0x43, 0x39, 0x46, 0x32, 0x41, 0x38, 0x35, 0x46,
		  0x30, 0x37, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe8, 0x1b, 0xe6, 0x01,
		  0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x0b, 0x4b, 0x81, 0x0a, 0x00, 0x08,
		  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x4b, 0x82, 0x0a, 0x83, 0xd5,
		  0x89, 0x8c, 0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xd5,
		  0x8a, 0x8c, 0x83, 0x60, 0xd1, 0x0f, 0x00, 0x08, 0xa0, 0x00, 0x00, 0x00,
		  0x20, 0x00, 0x00, 0x60, 0xd2, 0x0f, 0x83, 0xed, 0xe8, 0xc5, 0x00, 0x08,
		  0xc0, 0x00, 0x00, 0xc0, 0x2c, 0x00, 0x55, 0xaa
};


int SCSIDevice::processRead10(SCSI_CBD_READ_10 &cbd, uint8_t* &data, uint16_t& len) {

	uint32_t LBA = toUint32(cbd.LBA_a);
	uint16_t txlen = toUint16(cbd.length_a);
	//debug+=" read LBA:"+String(LBA)+" txlen:"+String(txlen)+"\n";
	lcdConsole.println("Read lba:"+String(LBA) +"ul:"+String(len)
			+ "sl:"+String(txlen * blockSize));


	//if (LBA > lastLBA) error();
	//if (cbd.length == 0) len=0;
	//uint8_t r = 1; //sdCard->readBlock(cbd.LBA, blockData);

	if (LBA==0){
		memset(blockData, 0, len);
		memcpy(blockData, BLOCK0, 512);
	} else
		for(int i=0; i< len; i++) {
			blockData[i] = (i%16)+0x41;
		}
	data = blockData;
	len = txlen * blockSize;
	return len;

	/*if (r) {
		//data = blockData;
		//len = txlen;
		return len;
	}
	else {
		data = NULL;
		len = 0;
		sdCardErrorCode = sdCard->errorCode();
		sdCardErrorData = sdCard->errorData();
		return ERROR_MEDIA_READ;
	}
	*/
}

int SCSIDevice::processWrite10(SCSI_CBD_WRITE_10  &cbd, uint8_t* &data, uint16_t& len) {
	lcdConsole.println("Write10:"+ String(len));
	lcdConsole.refresh();

	/*
	uint8_t r = sdCard->writeBlock(cbd.LBA, blockData);
	if (r) {
		data = blockData;
		len = 512;
		return len;
	}
	else {
		data = NULL;
		len = 0;
		sdCardErrorCode = sdCard->errorCode();
		sdCardErrorData = sdCard->errorData();
		return ERROR_MEDIA_READ;
	}
	*/
	return len;
}


int SCSIDevice::processRequest(SCSI_CBD &cbd, uint8_t* &data, uint16_t& len){

	if (cbd.generic.opcode == SCSI_READ_10){
		int r = processRead10(cbd.read10, data, len);
		return r;
	};
	if (cbd.generic.opcode == SCSI_WRITE_10){
		//debug += "  WRITE10\n";
		int r = processWrite10(cbd.write10, data, len);
		return r;
	};
	if (cbd.generic.opcode == SCSI_TEST_UNIT_READY){
		//debug += "  TEST_UNIT_READY\n";
		int r = processTestUnitReady(cbd.unit_ready, data, len);
		return r;
	};
	if (cbd.generic.opcode == SCSI_INQUIRY){
		//debug += "  INQUIRY\n";
		int r = processInquiry(cbd.inquiry, data, len);
		return r;
	};
	if (cbd.generic.opcode == SCSI_READ_CAPACITY_10){
		//debug += "  READ_CAPACITY_10\n";
		int r = processReadCapacity10(cbd.read_capacity10, data, len);
		return r;
	};
	if (cbd.generic.opcode == SCSI_MODE_SENSE_6){
		//debug += "  MODE_SENSE_6\n";
		int r = processModeSense6(cbd.mode_sense6, data, len);
		return r;
	};
	if (cbd.generic.opcode == SCSI_PREVENT_ALLOW_MEDIUM_REMOVAL){
		//debug += "  SCSI_PREVENT_ALLOW_MEDIUM_REMOVAL\n";
		int r = processMediumRemoval(cbd.medium_removal, data, len);
		return r;
	};

	lcdConsole.println("UNSUPPORTED:"+String(cbd.generic.opcode));
	lcdConsole.refresh();

	return SCSI_UNSUPPORTED_OPERATION;
}


